#!/usr/bin/env python

"""A Python replacement for appveyor-script.bat.
"""

from __future__ import print_function
import sys, os, time

# These can be rather slow:
#
URLs = { 'djgpp':   'http://www.watt-32.net/CI/dj-win.zip',
         'watcom':  'http://www.watt-32.net/CI/watcom20.zip',
         'borland': 'http://www.watt-32.net/CI/borland.zip'
       }

builders = [ "visualc", "clang", "mingw32", "mingw64", "borland", "djgpp", "watcom" ]

#
# When testing locally, there should be no '%APPVEYOR_PROJECT_NAME%'
#
if os.getenv ("APPVEYOR_PROJECT_NAME"):
  local_test = 0
else:
  local_test = 1

if local_test:
  try:
    from colorama import init, Fore, Style
    init()
    colour_off    = Style.RESET_ALL
    colour_red    = Fore.RED + Style.BRIGHT
    colour_yellow = Fore.YELLOW + Style.BRIGHT

  except ImportError:
    colour_off    = ""
    colour_red    = ""
    colour_yellow = ""

else:    # Use ESC-sequences on ApppVeyor
  colour_yellow = "\e[1;33m"
  colour_red    = "\e[1;31m"
  colour_off    = "\e[0m"

def cprint (s):
  print ("%s%s%s" % (colour_yellow, s, colour_off), end="")

def Fatal (s):
  print ("%s%s%s" % (colour_red, s, colour_off))
  sys.exit (1)

#
# Create a .bat file in '%TEMP' and run it via 'cmd /c file.bat'
#
def write_and_run_bat (fname, content, args=""):
  bat = os.getenv("TEMP") + "\\" + fname
  f = open (bat, 'wt+')
  f.write (':: Generated by %s at %s\n' % (__file__, time.ctime()))
  for l in content:
    f.write (l + '\n')
  f.close()
  return os.system ("cmd /c %s %s" % (bat, args))

#
# Env-vars common to 'build_src' and 'build_bin' and 'build_tests'
#
def get_env_vars_common():
  env_var = {}

  global local_test
  if local_test:
    watt_root = os.getenv ("WATT_ROOT")
    if not watt_root:
       Fatal ("WATT_ROOT not set!")
  else:
    watt_root = "c:\projects\watt-32"

  cpu     = os.getenv ("CPU", "x86")
  builder = os.getenv ("BUILDER", None)

  if not builder:
    Fatal ("BUILDER not set!")

  if not builder in builders:
    Fatal ("Illegal BUILDER: '%s'." % builder)

  env_var['APPVEYOR_BUILD_FOLDER'] = watt_root
  env_var['LOCAL_TEST'] = local_test
  env_var['WATT_ROOT']  = watt_root
  env_var['BUILDER']    = builder
  env_var['CPU']        = cpu
  env_var['CL']         = ''
  env_var['MODEL']      = os.getenv ('MODEL', 'none')
  env_var['PATH']       = os.getenv ('PATH')

  if cpu == 'x86':
    env_var['BITS'] = '32'
  else:
    env_var['BITS'] = '64'

  #
  # Download stuff and install packages here:
  #
  env_var['CI_ROOT'] = env_var['APPVEYOR_BUILD_FOLDER'] + r'\CI-temp'

  if builder == 'mingw32' or builder == 'mingw64':
    env_var['MINGW32'] = watt_root.replace ("\\","/")
    env_var['MINGW64'] = watt_root.replace ("\\","/")

  #
  # Set the dir for djgpp cross-environment.
  # Use forward slashes for this. Otherwise 'sh' + 'make' will get confused.
  # 7z can create only 1 level of missing directories. So a '%CI_ROOT%\djgpp' will not work
  #
  if builder == 'djgpp':
    env_var['DJGPP']     = env_var['CI_ROOT'].replace ("\\","/")
    env_var['DJ_PREFIX'] = env_var['DJGPP'] + '/bin/i586-pc-msdosdjgpp-'

  if builder == 'watcom':
    env_var['WATCOM']      = env_var['CI_ROOT']
    env_var['NT_INCLUDE']  = env_var['WATCOM'] + r'\h;' + env_var['WATCOM'] + r'\h\nt'
    env_var['DOS_INCLUDE'] = env_var['WATCOM'] + r'\h'
    env_var['PATH']       =  env_var['WATCOM'] + r'\binnt;' + env_var['PATH']

  if builder == 'borland':
    env_var['BCCDIR']  = env_var['CI_ROOT']
    env_var['INCLUDE'] = env_var['BCCDIR'] + r'\include\windows;' + env_var['BCCDIR'] + r'\include\windows\sdk'
    env_var['CBUILDER_IS_LLVM_BASED'] = '1'
    env_var['PATH'] = env_var['BCCDIR'] + r'\bin;' + env_var['PATH']

  if builder == 'clang' and cpu == 'x86':
    env_var['PATH'] = r'c:\Program Files\LLVM\bin;' + env_var['PATH']

  env_var['WSOCK_TRACE_LEVEL'] = '0'

  return env_var

#
# Env-vars for 'build_bin':
#
def get_env_vars_bin():
  bin_vars = {}

  bin_vars['PROGS_DJ'] = 'bping.exe ping.exe finger.exe ident.exe htget.exe tcpinfo.exe tracert.exe country.exe'
  bin_vars['PROGS_VC'] = 'ping.exe finger.exe tcpinfo.exe host.exe htget.exe tracert.exe con-test.exe gui-test.exe lpq.exe lpr.exe ntime.exe whois.exe ident.exe country.exe'
  bin_vars['PROGS_MW'] = bin_vars['PROGS_VC']    #  MinGW-w64
  bin_vars['PROGS_CL'] = bin_vars['PROGS_VC']    #  clang-cl Win32
  bin_vars['PROGS_BC'] = bin_vars['PROGS_VC']    #  Borland/CBuilder Win32

  bin_vars['PROGS_WC_WIN']     = 'ping.exe htget.exe finger.exe tcpinfo.exe con-test.exe gui-test.exe htget.exe tracert.exe whois.exe'
  bin_vars['PROGS_WC_LARGE']   = 'ping.exe htget.exe finger.exe tcpinfo.exe htget.exe whois.exe'
  bin_vars['PROGS_WC_FLAT']    = bin_vars['PROGS_WC_LARGE']
  bin_vars['PROGS_WC_SMALL32'] = bin_vars['PROGS_WC_LARGE']
  return bin_vars


#
# The progress callback for 'urllib.urlretrieve()'.
#
def url_progress (blocks, block_size, total_size):
  if blocks:
    percent = 100 * (blocks * block_size) / total_size
    kBbyte_so_far = (blocks * block_size) / 1024
    cprint ("Got %d kBytes (%u%%)\r" % (kBbyte_so_far, percent))

#
# Check if a local 'fname' exist. Otherwise download it from 'url'
# and unzip it using '7z'.
#
def download_and_install (fname, url):
  if os.path.exists(fname):
    cprint ("A local %s already exist.\n" % fname)
    return 0

  try:
    from urllib import urlretrieve as url_get
  except ImportError:
    from urllib.request import urlretrieve as url_get

  cprint ("url_get: %s -> %s.\n" % (url, fname))
  url_get (url, filename = fname, reporthook = url_progress)
  print ("")
  directory = os.path.dirname (fname)
  cprint ("Unzipping %s to %s.\n" % (fname, directory))
  r = os.system ("7z x -y -o%s %s > NUL" % (directory, fname))
  if r != 0:
    Fatal ("7z failed: %d." % r)

def generate_oui():
  cprint ("Generating 'src/oui-generated.c'.")
  r = os.system ("python.exe make-oui.py > oui-generated.c")
  cprint ("--------------------------------------------------------------------------------------------------")
  return r

#
# Print some usage.
#
def show_help():
  print ("%sUsage: %s [build_src | build_bin | build_tests | fake_test]" % (__doc__, __file__))
  sys.exit (0)

def get_env_string (envs):
  ret = ""
  for e in iter(envs):
     ret += 'set %s=%s\n' % (e, envs[e])
  return ret

#
# Print a colourised message and return the makefile command for 'build_src':
#
def get_src_make_command (builder, cpu, model=""):
  bits = '32'
  if cpu == 'x64':
    bits = '64'

  if builder == 'visualc':
     cprint ("[%s]: Building release:\n" % cpu)
     return 'nmake -nologo -f visualc-release_%s.mak' % bits

  if builder == 'clang':
     cprint ("[%s]: Building release:\n" % cpu)
     return 'make -f clang-release_%s.mak' % bits

  if builder == 'mingw32':
     cprint ("[%s]: Building:\n" % cpu)
     return 'make -f MinGW32.mak'

  if builder == 'mingw64':
     cprint ("[%s]: Building:\n" % cpu)
     return 'make -f MinGW64_%s.mak' % bits

  if builder == 'djgpp':
     cprint ("[%s]: Building:\n" % cpu)
     return 'make -f djgpp.mak'

  if builder == 'borland':
     cprint ("[%s]: Building:\n" % cpu)
     return '%s\\bin\\make -f bcc_w.mak' % env_vars['BCCDIR']

  if builder == 'watcom':
    if model == 'win32':
      cprint ("[%s]: Building for Watcom/Win32:\n" % cpu)
      return 'wmake -h -f watcom_w.mak'

    if model == 'flat':
      cprint ("[%s]: Building for Watcom/flat:\n" % cpu)
      return 'wmake -h -f watcom_f.mak'

    if model == 'large':
      cprint ("[%s]: Building for Watcom/large:\n" % cpu)
      return 'wmake -h -f watcom_l.mak'

    Fatal ("[%s]: BUILDER Watcom  needs a MODEL!" % cpu)

  Fatal ("[%s]: I did not expect this!" % cpu)


#
# Print a colourised message and return the makefile command for 'build_bin':
#
def get_bin_make_command (env_vars):
  builder = env_vars['BUILDER']
  cpu     = env_vars['CPU']

  if builder == 'djgpp':
    cprint ('[%s]: Building PROGS_DJ=%s:' % (cpu, env_vars['PROGS_DJ']))
    return 'make -f djgpp_win.mak DPMI_STUB=0 %s' % env_vars['PROGS_DJ']

  if builder == 'visualc':
     cprint ("[%s]: Building PROGS_VC=%s\n" % (cpu, env_vars['PROGS_VC']))
     return 'nmake -nologo -f visualc.mak %s' % env_vars['PROGS_VC']

  if builder == 'mingw64':
     cprint ("[%s]: Building PROGS_MW=%s\n" % (cpu, env_vars['PROGS_MW']))
     return 'make -f mingw64.mak %s' % env_vars['PROGS_MW']

  if builder == 'clang':
     cprint ("[%s]: Building PROGS_CL=%s\n" % (cpu, env_vars['PROGS_CL']))
     return 'make -f clang.mak %s' % env_vars['PROGS_CL']

  if builder == 'borland':
     cprint ("[%s]: Building PROGS_BC=%s\n" % (cpu, env_vars['PROGS_BC']))
     return '%s\\bin\\make -f bcc_win.mak %s' % (env_vars['BCCDIR'], env_vars['PROGS_BC'])

  if builder == 'watcom':
    model =  env_vars['MODEL']
    if model == 'win32':
      cprint ('[%s]: watcom/Win32: Building PROGS_WC_WIN=%s' % (cpu, env_vars['PROGS_WC_WIN']))
      return 'wmake -h -f wc_win.mak %s' % env_vars['PROGS_WC_WIN']

    if model == 'flat':
      cprint ('[%s]: watcom/flat: Building PROGS_WC_FLAT=%s' % (cpu, env_vars['PROGS_WC_FLAT']))
      return 'wmake -h -f causeway.mak %s' % env_vars['PROGS_WC_FLAT']

    if model == 'large':
      cprint ('[%s]: watcom/large: Building PROGS_WC_LARGE=%s' % (cpu, env_vars['PROGS_WC_LARGE']))
      return 'wmake -h -f watcom.mak %s' % env_vars['PROGS_WC_LARGE']

    Fatal ("[%s]: BUILDER Watcom  needs a MODEL!" % cpu)

  cprint ("[%s]: No 'build_bin' for 'BUILDER=%s' yet." % (cpu, builder))

#
# Concatinate 2 dictionaries:
#   https://stackoverflow.com/questions/38987/how-do-i-merge-two-dictionaries-in-a-single-expression/26853961#26853961
#
def merge_dicts (a, b):
  r = a.copy()   # start with a's keys and values
  r.update(b)    # modifies r with b's keys and values & returns None
  return r

def run_test (prog, args=[]):
  cmd = prog + ' ' + ' '.join(args)
  cprint ("Running test '%s' ---------------------------------------------------------------\n" % cmd)
  return os.system (cmd)

def main():
  if len(sys.argv) != 2 or \
     sys.argv[1] not in ["build_src", "build_bin", "build_tests", "fake_test"]:
    show_help()

  env_vars = get_env_vars_common()

  base = os.path.basename(__file__)
  file = env_vars['APPVEYOR_BUILD_FOLDER'] + '\\' + base

  if not os.path.exists(base):
    Fatal ("Run %s from it's directory." % file)

  os.system ("md %s 2> NUL" % env_vars['CI_ROOT'])

  try:
    builder  = os.getenv ("BUILDER")
    zip_file = env_vars['CI_ROOT'] + '\\' + os.path.basename (URLs[builder])
    download_and_install (zip_file, URLs[builder])
  except KeyError:
    # No need to install anything for this '%BUILDER%'
    pass

  if sys.argv[1] == 'fake_test':
    r = write_and_run_bat ("fake_test.bat",
                           [ '@echo off',
                             'setlocal',
                             get_env_string(env_vars),
                             'echo BUILDER: %BUILDER%',
                             'echo CPU:     %CPU%',
                             'echo MODEL:   %MODEL%',
                             'echo arg1:    "%1"'
                           ],
                           sys.argv[1])

  elif sys.argv[1] == 'build_src':
    os.chdir ('src')
    if generate_oui() == 0:
      env_vars['CL'] = '-DHAVE_OUI_GENERATATED_C'

    write_and_run_bat ("build_src_1.bat",
                       [ '@echo off',
                         'setlocal',
                         'prompt $P$G',
                         get_env_string (env_vars),
                         'call configur.bat %s' % builder
                       ] )

    r = write_and_run_bat ("build_src_2.bat",
                           [ '@echo off',
                             'setlocal',
                             'prompt $P$G',
                             get_env_string (env_vars),
                             get_src_make_command (builder, env_vars['CPU'], env_vars['MODEL'])
                           ] )

  elif sys.argv[1] == 'build_bin':
    os.chdir ('bin')
    bin_vars = get_env_vars_bin()
    r = write_and_run_bat ("build_bin.bat",
                           [ '@echo off',
                             'setlocal',
                             'prompt $P$G',
                             get_env_string (env_vars),
                             get_env_string (bin_vars),
                             get_bin_make_command (merge_dicts(env_vars, bin_vars))
                           ] )

  elif sys.argv[1] == 'build_tests':
    r = write_and_run_bat ("build_test.bat",
                           [ '@echo off',
                             'prompt $P$G',
                             get_env_string (env_vars),
                             r'src\tests',
                             r'call configur.bat %BUILDER%',
                             r'if %BUILDER%. == borland.  make -f bcc_w.mak',
                             r'if %BUILDER%. == djgpp.    make -f djgpp.mak',
                             r'if %BUILDER%. == clang.    make -f clang_%BITS%.mak',
                             r'if %BUILDER%. == mingw64.  make -f MinGW64_%BITS%.mak',
                             r'if %BUILDER%. == visualc.  make -f visualc_%BITS%.mak',
                             r'if %BUILDER%. == watcom. (',
                             r'   if %MODEL%. == large. make -f watcom_l.mak',
                             r'   if %MODEL%. == flat.  make -f watcom_f.mak',
                             r'   if %MODEL%. == win32. make -f watcom_w.mak',
                             ')',
                           ] )
    os.chdir ('src\\tests')
    run_test ('cpu.exe')
    run_test ('cpuspeed.exe', ['1', '1'])
    run_test ('swap.exe')
    run_test ('chksum.exe', ['-s'])

  if r:
    cprint ("r: %d" % r)

if __name__ == '__main__':
  main()

